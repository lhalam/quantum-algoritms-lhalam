"""
Алгоритм Дойча-Йожи

Цей модуль реалізує алгоритм Дойча-Йожи для визначення, чи є задана
булева функція сталою або збалансованою за допомогою одного запиту до оракула.

Основні функції:
- circuit(input_string='01010101'): Створює та виконує квантову схему для
  заданого бінарного рядка (довжина повинна бути степенем двійки). Повертає
  словник з полем 'result' (Qobj), що представляє вектор стану після виконання.
- results(input_string, result): Інтерпретує та виводить результати.
- visualize_results(result): Візуалізує ймовірності квантових станів.

Залежності: qutip, numpy
"""

import math

import numpy as _np
from numpy import *
from qutip import basis, tensor, qeye, Qobj
import matplotlib.pyplot as plt


# Локальні реалізації для hadamard_transform та cnot (для уникнення проблем з імпортом при статичному аналізі)
def hadamard_transform(n):
    """
    Генерує матрицю Адамара для одного кубіта.

    Параметри:
        n (int): Розмір матриці (завжди 1).

    Повертає:
        Qobj: Матриця Адамара.
    """
    h = (1.0 / _np.sqrt(2.0)) * _np.array([[1, 1], [1, -1]])
    return Qobj(h)


def cnot():
    """
    Генерує матрицю CNOT.

    Повертає:
        Qobj: Матриця CNOT.
    """
    return Qobj(_np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]))


##############################################################################
# Налаштування та виконання схеми
##############################################################################

# Встановлюємо input_string як вхідну функцію. Кількість символів у рядку
# має бути степенем двійки ($2^n$). Алгоритм Дойча-Йожи вимагає, щоб цей
# рядок був або повністю з 0, або повністю з 1 (обидва варіанти сталі),
# або мав однакову кількість 0 і 1 (збалансована, але порядок не має значення).

def circuit(input_string='01010101'):
    """
    Створює та виконує квантову схему для алгоритму Дойча-Йожи.

    Параметри:
        input_string (str): Бінарний рядок довжини 2**n, що представляє функцію f.

    Повертає:
        dict: Словник, що містить 'input_string' та 'result' (Qobj).
    """

    input_string_length = input_string.__len__()
    # Кількість необхідних кубітів, $n = \log_2(довжина\_рядка)$
    required_qubits = int(math.log(input_string_length, 2))

    # Створюємо масив кубітів. Вхідний рядок довжини $2^n$ вимагає $n$ кубітів,
    # що починаються в стані $|0\rangle$, плюс один контрольний кубіт, що починається в стані $|1\rangle$.
    qubits = []
    for i in range(required_qubits):
        qubits.append(basis(2, 0))  # Кубіти в стані |0>
    qubits.append(basis(2, 1))  # Контрольний кубіт у стані |1>

    # Кубіти об'єднуються у спільний стан за допомогою тензорного добутку
    Q = None
    for qubit in qubits:
        if Q:
            Q = tensor(Q, qubit)
        else:
            Q = tensor(qubit)

    # Вентилі Адамара як комбінована операція
    H = None
    for qubit in qubits:
        if H:
            H = tensor(H, hadamard_transform(1))
        else:
            H = hadamard_transform(1)

    # Вентилі Адамара + Одиничний вентиль (для контрольного кубіта) як комбінована операція
    HI = None
    for qubit in qubits[:-1]:
        if HI:
            HI = tensor(HI, hadamard_transform(1))
        else:
            HI = hadamard_transform(1)
    HI = tensor(HI, qeye(2))

    # Uf генерується шляхом створення нульової матриці відповідного розміру,
    # а потім встановлення 1 там, де це необхідно.
    Uf = zeros([input_string_length * 2, input_string_length * 2])
    for i in range(input_string_length):
        if input_string[i] == '0':
            # Оракул для f(x)=0: |x>|y> -> |x>|y XOR 0>
            Uf[i * 2, i * 2] = 1
            Uf[i * 2 + 1, i * 2 + 1] = 1
        else:
            # Оракул для f(x)=1: |x>|y> -> |x>|y XOR 1>
            Uf[i * 2 + 1, i * 2] = 1
            Uf[i * 2, i * 2 + 1] = 1

    # Переконуємося, що Uf є об'єктом Qobj і має правильні розмірності тензорного добутку, щоб відповідати H
    Uf = Qobj(Uf)
    # Якщо H є оператором з розмірностями тензорного добутку, переконуємося, що Uf використовує ті самі розмірності
    try:
        Uf.dims = H.dims
    except Exception:
        pass # Якщо H не має dims, пропускаємо встановлення

    # Запускаємо квантову схему: |0...01> -> H|0...01> -> Uf H|0...01> -> HI Uf H|0...01>
    result = HI * Uf * H * Q
    return ({'input_string': input_string, 'result': result})


##############################################################################
# Інтерпретація та виведення результатів.
##############################################################################

def results(input_string, result):
    """
    Інтерпретує та виводить результати алгоритму Дойча-Йожи.

    Параметри:
        input_string (str): Вхідний бінарний рядок, що представляє функцію f.
        result (Qobj): Вектор стану після виконання схеми.

    Виводить:
        Амплітуди/ймовірності та інтерпретацію (стала/збалансована).
    """

    print('-' * 60)
    vec = result.full().flatten()
    array_length = vec.size
    # Загальна кількість кубітів (n+1)
    elements = int(math.log(array_length, 2))
    # Виводимо амплітуди для кожного базисного стану
    for i in range(array_length):
        print("|" + "{0:b}".format(i).zfill(elements) + ">" + " " + str(vec[i].real))
    print('-' * 60)

    # Виграшні елементи - це стани, де перші n кубітів (вхідні) дорівнюють 0...0
    # Наприклад, для n=3, це стани |0000> та |0001>
    winning_elements = "0" * (elements - 1)
    probability_winning_elements = (abs(vec[0]) ** 2 + abs(vec[1]) ** 2)

    print("Ймовірність вимірювання |" + winning_elements + "0> або |" + winning_elements + "1>: " + str(
        round(probability_winning_elements, 6)))

    print("Вхідні дані         :", input_string)

    # Інтерпретуємо результати: якщо ймовірність вимірювання вхідних кубітів у
    # стані |0...0> близька до 1, функція є сталою.
    # Це еквівалентно тому, що амплітуди |0...00> або |0...01>
    # (vec[0] або vec[1]) близькі до $\pm 1 / \sqrt{2^n}$ (за винятком похибок округлення).
    # Для $n=3$ ($2^n=8$) це $\pm 1/\sqrt{8} \approx \pm 0.3535$.
    # Для $n=1$ ($2^n=2$) це $\pm 1/\sqrt{2} \approx \pm 0.707$.
    # Тут використовуємо просту перевірку на основі прикладу n=1 (Дойча), де амплітуда > 0.5.
    # Для загального випадку потрібно порівнювати з $1/\sqrt{2^{n+1}}$.
    if (abs(vec[0]) > 0.5 or abs(vec[1]) > 0.5):
        print('Інтерпретація: стала', end='')
        # Перевірка правильності інтерпретації
        if ((input_string == '1' * len(input_string)) or (input_string == '0' * len(input_string))):
            print(" (підтверджено)")
        else:
            print(" (помилка)")
    else:
        print('Інтерпретація: збалансована', end='')
        # Перевірка правильності інтерпретації
        if ((input_string.count('1') == input_string.count('0'))):
            print(" (підтверджено)")
        else:
            print(" (помилка)")
    print('-' * 60)


def visualize_results(result):
    """
    Візуалізує ймовірності квантових станів.

    Параметри:
        result (Qobj): Вектор стану після виконання схеми.
    """
    probabilities = abs(result.full().flatten())**2
    # Обчислюємо кількість кубітів (n+1)
    num_qubits = int(math.log(len(probabilities), 2))
    # Формуємо мітки станів |00...0>
    states = [f"|{bin(i)[2:].zfill(num_qubits)}>" for i in range(len(probabilities))]

    plt.bar(states, probabilities, color='green', alpha=0.7)
    plt.xlabel("Квантові стани")
    plt.ylabel("Ймовірності")
    plt.title("Ймовірності квантових станів (Дойча-Йожи)")
    plt.xticks(rotation=90)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()


if __name__ == '__main__':
    """
    Виконує схему алгоритму Дойча-Йожи та інтерпретує результати.
    """
    ##############################################################################
    # Запуск схеми Дойча-Йожи та інтерпретація результатів
    ##############################################################################
    # Отримуємо вихід схеми на основі вхідного рядка (за замовчуванням '01010101');
    # допустимі входи, наприклад, '00000000' або '11111111' (стала) або
    # '01010101' (збалансована). Дивіться коментарі вище для деталей.
    #
    output = circuit('00000000') # (стала)
    # output = circuit('11111111') # (стала)
    # output = circuit('01010101') # (збалансована)

    # Інтерпретуємо та виводимо результати виконання схеми
    results(output['input_string'], output['result'])

    # Візуалізуємо результати
    visualize_results(output['result'])