"""
Алгоритм Дойча

Цей модуль реалізує алгоритм Дойча для визначення, чи є задана
булева функція сталою або збалансованою.

Основні функції:
- circuit(input_string='11'): Створює та виконує квантову схему для заданого
  бінарного рядка. Повертає словник з полем 'result' (Qobj), що представляє
  вектор стану після виконання.
- results(input_string, result): Інтерпретує та виводить результати.
- visualize_results(result): Візуалізує ймовірності квантових станів.

Залежності: qutip, numpy
"""

from typing import Dict, Any

import matplotlib.pyplot as plt
import numpy as _np
from numpy import *
from qutip import basis, tensor, sigmax, qeye, Qobj


# Надаємо явні посилання на функції, що використовуються з qutip.qip.operations,
# щоб уникнути проблем зі статичним аналізом. Визначаємо невеликі запасні варіанти
# безумовно, щоб файл був самодостатнім для статичного аналізу та простого виконання.
def hadamard_transform(n):
    """
    Генерує матрицю Адамара для одного кубіта.

    Параметри:
        n (int): Розмір матриці (завжди 1).

    Повертає:
        Qobj: Матриця Адамара.
    """
    h = (1.0 / _np.sqrt(2.0)) * _np.array([[1, 1], [1, -1]])
    return Qobj(h)


def cnot():
    """
    Генерує матрицю CNOT.

    Повертає:
        Qobj: Матриця CNOT.
    """
    return Qobj(_np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]))


##############################################################################
# Налаштування та виконання схеми
##############################################################################

def circuit(input_string: str = '11') -> Dict[str, Any]:
    """
    Створює та виконує квантову схему для алгоритму Дойча.

    Параметри:
        input_string (str): Бінарний рядок, що представляє функцію f.
        Допустимі значення: '00', '11' (стала функція) або '01', '10' (збалансована функція).

    Повертає:
        dict: Словник, що містить 'input_string' та 'result' (Qobj).
    """

    ##############################################################################
    # Спочатку встановлюємо вхідний рядок, залежно від f. Він має бути одним із
    # наступних варіантів. 'input_string' - це просто вишуканий спосіб опису f.
    # '00' означає вихід 0 (перша цифра) для f(0), за яким слідує вихід 0
    # (друга цифра) для f(1); аналогічно для інших.
    ##############################################################################
    # input_string = '00' # Стала - f(x) = 0
    # input_string = '11' # Стала - f(x) = 1
    # input_string = '01' # Збалансована = f(x) = x
    # input_string = '10' # Збалансована = f(x) = not-x
    ##############################################################################

    ##############################################################################
    # Налаштовуємо всі елементи, необхідні для виконання квантової схеми
    # алгоритму Дойча, і запускаємо алгоритм.
    ##############################################################################

    # Верхній (q0) та нижній (q1) кубіти
    q0 = basis(2, 0)  # верхній кубіт у стані |0>
    q1 = basis(2, 1)  # нижній кубіт у стані |1>

    # Вентилі, що використовуються в алгоритмі
    I = qeye(2)  # одиничний вентиль (квантовий провід)
    H = hadamard_transform(1)  # вентиль Адамара
    NOT = sigmax()  # вентиль NOT (X)
    CNOT = cnot()  # вентиль CNOT

    ##############################################################################
    # Конструюємо вентиль Uf на основі input_string відповідно до наступної схеми:
    # '00' ==> одиничний вентиль (квантовий провід) на верхньому та нижньому кубітах
    # '11' ==> одиничний вентиль на верхньому кубіті, NOT (X) на нижньому кубіті
    # '01' ==> CNOT (керування на верхньому кубіті)
    # '10' ==> CNOT (керування на верхньому кубіті), за яким слідує одиничний
    #          вентиль на верхньому кубіті та NOT на нижньому кубіті
    ##############################################################################

    if input_string == '00':
        Uf = tensor(I, I)
    elif input_string == '11':
        Uf = tensor(I, NOT)
    elif input_string == '01':
        Uf = CNOT
    elif input_string == '10':
        Uf = CNOT * tensor(I, NOT)
    else:
        print("Помилка вхідного рядка")
        raise SystemExit(0)

    # Тензори для комбінованих станів
    Q = tensor(q0, q1)
    HH = tensor(H, H)
    HI = tensor(H, I)

    # Запускаємо квантову схему
    result = HI * Uf * HH * Q
    return ({'input_string': input_string, 'result': result})


##############################################################################
# Інтерпретація та виведення результатів.
##############################################################################

def results(input_string: str, result: Any) -> None:
    """
    Інтерпретує та виводить результати алгоритму Дойча.

    Параметри:
        input_string (str): Вхідний бінарний рядок, що представляє функцію f.
        result (Qobj): Вектор стану після виконання схеми.

    Виводить:
        Амплітуди/ймовірності та інтерпретацію (стала/збалансована).
    """

    print('-' * 60)
    # Використовуємо числовий вектор з Qobj для безпечної індексації
    vec = result.full().flatten()
    print("|00>", vec[0])
    print("|01>", vec[1])
    print("|10>", vec[2])
    print("|11>", vec[3])
    print('-' * 60)

    probability_00_01 = abs(vec[0]) ** 2 + abs(vec[1]) ** 2
    probability_10_11 = abs(vec[2]) ** 2 + abs(vec[3]) ** 2

    # Вимірювання |00> або |01> означає, що верхній кубіт знаходиться в стані |0>
    print('Ймовірність вимірювання |00> або |01|: ', float(probability_00_01))
    # Вимірювання |10> або |11> означає, що верхній кубіт знаходиться в стані |1>
    print('Ймовірність вимірювання |10> або |11|: ', float(probability_10_11))

    if abs(probability_00_01 - 1.0) < 1e-9:
        print("Інтерпретація: Стала (верхній кубіт вимірюється в стані |0>)")
        if (input_string == '00' or input_string == '11'):
            print("Функція      : Стала (підтверджено)")
        else:
            print("Помилка (інтерпретація не збігається з функцією)")
    elif abs(probability_10_11 - 1.0) < 1e-9:
        print("Інтерпретація: Збалансована (верхній кубіт вимірюється в стані |1>)")
        if (input_string == '10' or input_string == '01'):
            print("Функція      : Збалансована (підтверджено)")
        else:
            print("Помилка (інтерпретація не збігається з функцією)")
    else:
        print("Помилка (неможливо інтерпретувати)")

    print('-' * 60)


def visualize_results(result):
    """
    Візуалізує ймовірності квантових станів.

    Параметри:
        result (Qobj): Вектор стану після виконання схеми.
    """
    probabilities = abs(result.full().flatten()) ** 2
    states = ["|00>", "|01>", "|10>", "|11>"]

    plt.bar(states, probabilities, color='blue', alpha=0.7)
    plt.xlabel("Квантові стани")
    plt.ylabel("Ймовірності")
    plt.title("Ймовірності квантових станів")
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()


if __name__ == "__main__":
    """
    Виконує схему алгоритму Дойча та інтерпретує результати.
    """
    # Отримуємо вихід схеми на основі вхідного рядка (за замовчуванням '11');
    # допустимі входи: '00', '11' (стала) або '01', '10' (збалансована). Дивіться
    # коментарі вище для більш детальної інформації.
    for data in ['00', '11']: # ToDo not working for '01', '10' ?
        print(f"Вхідні дані: {data}")
        output = circuit(data)

        # Інтерпретуємо та виводимо результати виконання схеми
        results(output['input_string'], output['result'])

        # Візуалізуємо результати
        visualize_results(output['result'])

    # old code:
    # output = circuit('11')
    #
    # # Інтерпретуємо та виводимо результати виконання схеми
    # results(output['input_string'], output['result'])
    #
    # # Візуалізуємо результати
    # visualize_results(output['result'])
